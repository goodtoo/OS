# 操作系统内核编写项目报告

## 一、项目目的

本项目的目标是**从零编写一个简化的操作系统内核**。通过构建交叉编译环境、使用 GRUB 完成引导加载、利用链接脚本布置内核内存布局，并在内核中实现若干核心功能，使内核能够在 QEMU/Bochs 模拟器中成功运行。

主要功能包括：

1. **内核入口与启动流程**：通过 GRUB 加载内核，利用 `boot.S` 建立执行环境，并跳转至内核主函数 `main`。
2. **内存管理**：基于 GRUB 提供的内存信息，完成内存初始化与动态分配接口，实现内核级内存管理。
3. **中断与异常处理**：构建全局描述符表（GDT）和中断描述符表（IDT），并完成时钟中断的初始化与处理中断机制。
4. **系统调用机制**：基于 `syscall` 指令，建立用户态与内核态的交互通道，支持基础系统调用功能。
5. **多线程支持**：设计并实现线程管理模块，能够创建并调度多个线程，实现内核级并发执行。

## 二、实验环境

**操作系统**：Ubuntu 20.04/22.04

**编译工具链**：`x86_64-elf-gcc`、`ld`、`nasm`

**构建工具**：`xmake`

**引导加载器**：`GRUB2 (Multiboot2)`

**模拟器**：`QEMU`、`Bochs`

## 三、项目结构

实验工程的主要文件和目录如下：

`src/`：核心源码目录

​	`boot/boot.S`：启动汇编代码，提供 `_start` 入口，调用 `main`

​	`kernel/*.c`：内核核心模块（内存管理、进程/线程、系统调用等）

​	`user/*.c`：用户态测试程序

​	`lib/*.c`：辅助函数（如 `printf`、`string` 库）

`build/`：编译生成目录，保存 `kernel.elf` 和 `kernel.iso`

`grub/grub.cfg`：GRUB 配置文件，指定加载内核

`main.c`：内核主函数，负责初始化各子系统并创建测试线程

`linker.ld`：链接脚本，定义内核加载地址和内存布局

`bochsrc`：Bochs 模拟器配置文件

`xmake.lua`：构建脚本，自动完成编译、链接和 ISO 镜像生成

## 四、关键代码与原理

### 1. 内核主函数（`main.c`）

内核的入口函数 `main` 完成以下工作：

1. **内存初始化**：调用 `memory_init(magic, addr)`，接收 GRUB 提供的启动信息，建立内存管理机制。
2. **终端与串口初始化**：`terminal_init()` 与 `serial_init()` 用于屏幕输出和串口调试。
3. **中断与 GDT 初始化**：设置中断描述符表和全局描述符表，保证内核能处理异常和中断。
4. **堆内存与时钟初始化**：`kheap_init()` 提供动态内存分配；`timer_init()` 设置时钟中断。
5. **系统调用与线程初始化**：注册系统调用表，建立线程管理机制。
6. **测试线程执行**：通过 `process_execute(thread_a, "proc_a")` 和 `process_execute(thread_b, "proc_b")` 创建并调度两个线程，测试系统调用机制。

**测试机制**： `thread_a` 调用 `syscall`，将 `RAX=1`； `thread_b` 调用 `syscall`，将 `RAX=0`。 说明内核已正确支持系统调用号传递与调度。

### 2. 链接脚本（`linker.ld`）

该文件定义了内核的段布局：

**GRUB Multiboot2 Header**：放置在低地址 1M 处，保证 GRUB 能识别并加载内核。

**.text / .rodata / .data / .bss**：分别存放代码、只读数据、已初始化数据、未初始化数据。

**高地址映射**：通过 `0xFFFFFFFF80000000` 将内核映射到内核空间，隔离用户态地址。

**符号导出**：如 `_kernel_phys_end`，用于确定内核大小和内存管理边界。

### 3. Bochs 配置（`bochsrc`）

设置内存 `megs: 32`

选择 `boot: cdrom`，从 `build/kernel.iso` 启动

开启 `magic_break`，支持 `BOCHS_BREAK` 指令触发断点

串口 `com1` 输出到文件 `com1_log`，便于调试

### 4. Xmake 构建脚本（`xmake.lua`）

定义 `x86_64-elf` 交叉编译工具链

添加 `src/boot`、`src/kernel`、`src/user` 源文件

设置编译参数：`-ffreestanding -nostdlib -mcmodel=kernel`，保证无标准库依赖

链接时使用 `linker.ld`，生成 `system.map`

构建完成后：

1. 拷贝 `kernel.elf` 到 `build/iso/boot/`
2. 添加 `grub.cfg`，生成 `kernel.iso`

提供 `on_run` 命令，可直接调用 `qemu-system-x86_64 -cdrom build/kernel.iso` 启动内核

## 五、运行步骤和结果

## 六、项目总结