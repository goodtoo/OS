# 第六阶段项目说明

## 一、项目目标

第六阶段的目标是实现一个**最小多任务调度器**，让内核能够在 **时钟中断**的驱动下轮流调度多个任务执行。

核心目标：

- 在内核中引入 **任务（task）抽象**
- 构建 **任务栈帧**，保证 `iret` 能正确切换到不同任务
- 通过 **PIT 时钟中断**触发任务切换
- 在屏幕上观察到多个任务轮流运行的结果

------

## 二、系统结构

### 1. Bootloader (`boot/boot.asm`)

- 负责 BIOS → 内核加载 → 切换保护模式
- 设置 **A20** 地址线、建立 GDT（只包含 null + code + data 三项）
- 从软盘加载内核到物理 `0x1000`
- 切换到保护模式后跳转到 `kernel_main`

启动时屏幕输出：

- `A` → Bootloader 开始
- `C` → 内核加载完成
- `S/Z` → 内核校验成功/失败
- `P` → 进入保护模式
- `J` → 准备跳入内核
- `K` → 内核启动成功

------

### 2. 内核核心 (`kernel/`)

- **kernel.c**
  - 内核入口 `kernel_main`
  - 初始化 **PMM 物理内存管理**、**IDT**、**PIC**、**PIT**
  - 调用 `sched_init()` 初始化调度器
  - 打印 `"Scheduler: 2 tasks..."`
  - 进入 `hlt` 循环等待中断
- **idt.c**
  - 设置 IDT
  - 定义中断服务函数入口
  - 配置 **PIT (8253/8254)** 为 100Hz 定时器
  - 处理时钟/键盘中断
- **isr.asm**
  - 异常/中断统一封装
  - 在时钟中断里调用 `sched_on_tick()`
  - 如果需要切换任务，则 `mov esp, new_task_esp` 并通过 `popa; add esp,4; iret` 跳转到新任务
- **pmm.c**
  - 简单的物理内存管理：基于位图的页分配/释放
  - 提供 `kmalloc_page()` 给调度器分配任务栈
- **sched.c**
  - 新增的**调度模块**
  - 定义 `task_t` 结构，保存每个任务的栈顶 ESP
  - `build_initial_esp()`：构造符合 `iret` 返回格式的“假栈”
  - `sched_init()`：创建两个 demo 任务
  - `sched_on_tick()`：在时钟中断中轮询切换任务

------

### 3. 链接脚本 (`kernel.ld`)

- 内核入口地址固定在 `0x1000`
- 统一 `.text .data .bss` 段布局

------

### 4. Makefile

- 编译 `boot.asm`、内核 C/ASM 文件
- 链接为 `kernel.elf` → `kernel.bin`
- 拼接为 `os-image`（启动软盘镜像）
- `make run` 用 QEMU 启动测试

------

## 三、构建流程

目录结构：

```
stage6/
├── boot/
│   └── boot.asm         # Bootloader
├── kernel/
│   ├── kernel.c         # 内核入口
│   ├── idt.c            # IDT + PIC + PIT
│   ├── isr.asm          # ISR 封装
│   ├── sched.c          # 调度器
│   ├── pmm.c/.h         # 物理内存管理
│   └── ...
├── kernel.ld            # 链接脚本
├── Makefile             # 构建脚本
```

编译运行：

```bash
make clean && make
make run
```

------

## 四、运行效果

1. 启动顺序：
   - `A C S P J K` 依次出现，确认 bootloader 到内核加载流程正确。
2. 内核输出：
   - `OK1  Stage 3: IDT+PIC+PIT+PMM`
   - `*MM free pages: 0x....`
   - `Scheduler: 2 tasks...`
3. Demo 任务执行：
   - 屏幕第 9 行持续输出 `111111...`
   - 屏幕第 10 行持续输出 `222222...`
   - 两行交替更新，说明调度器在时钟中断驱动下切换了任务。

![image-20250918125027359](C:\Users\Jump\AppData\Roaming\Typora\typora-user-images\image-20250918125027359.png)

------

## 五、技术要点

- **假栈构造**
  - 手动构造任务初始栈：`[EDI..EAX][VECTOR][EIP][CS=0x08][EFLAGS]`
  - 通过 `iret` 跳转到任务入口
- **上下文切换**
  - 当前任务的 ESP 在时钟中断中保存
  - 下一任务的 ESP 加载到 `esp`，再通过 `popa; add esp,4; iret` 跳转
- **调度算法**
  - 简单的**轮询调度**（Round-Robin）
  - 每次 tick 切换到下一个任务
- **保护模式运行**
  - GDT 只含 code/data 段，全部在 ring0 执行
  - 避免使用 TSS，避免复杂的硬件任务切换

------

## 六、阶段总结

第六阶段成功实现了**简易任务管理与调度器**：

- Bootloader → 内核 → IDT/PIC/PIT → 内存管理 → 调度器
- 内核能创建并管理多个任务
- 时钟中断触发任务切换，两个任务交替执行
- 系统具备了**最小多任务内核的雏形**